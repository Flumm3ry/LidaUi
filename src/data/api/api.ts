/// <reference path="./custom.d.ts" />
// tslint:disable
// @ts-nocheck
/**
 * lida-api
 * This is a REST API utilising the CQRS design pattern being exposed via Google Clouds serverless functions.
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from 'url'
import * as portableFetch from 'portable-fetch'
import { Configuration } from './configuration'

const BASE_PATH = '/'.replace(/\/+$/, '')

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ',',
  ssv: ' ',
  tsv: '\t',
  pipes: '|',
}

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string
  options: any
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = portableFetch
  ) {
    if (configuration) {
      this.configuration = configuration
      this.basePath = configuration.basePath || this.basePath
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: 'RequiredError'
  constructor(public field: string, msg?: string) {
    super(msg)
  }
}

/**
 *
 * @export
 * @interface CreateSensorDataCommandDto
 */
export interface CreateSensorDataCommandDto {
  /**
   *
   * @type {boolean}
   * @memberof CreateSensorDataCommandDto
   */
  isRunning: boolean
  /**
   *
   * @type {boolean}
   * @memberof CreateSensorDataCommandDto
   */
  operationSucceeded: boolean
}
/**
 *
 * @export
 * @interface CreateSystemLogCommandDto
 */
export interface CreateSystemLogCommandDto {
  /**
   *
   * @type {boolean}
   * @memberof CreateSystemLogCommandDto
   */
  isRunning: boolean
  /**
   *
   * @type {boolean}
   * @memberof CreateSystemLogCommandDto
   */
  operationSucceeded: boolean
}
/**
 *
 * @export
 * @interface GetSensorDataQueryDto
 */
export interface GetSensorDataQueryDto {
  /**
   *
   * @type {string}
   * @memberof GetSensorDataQueryDto
   */
  sensorName: string
  /**
   *
   * @type {number}
   * @memberof GetSensorDataQueryDto
   */
  value: number
  /**
   *
   * @type {number}
   * @memberof GetSensorDataQueryDto
   */
  timeStamp: number
}
/**
 *
 * @export
 * @interface GetSystemLogQueryDto
 */
export interface GetSystemLogQueryDto {
  /**
   *
   * @type {string}
   * @memberof GetSystemLogQueryDto
   */
  sensorName: string
  /**
   *
   * @type {number}
   * @memberof GetSystemLogQueryDto
   */
  timeStamp: number
}
/**
 *
 * @export
 * @interface UpdateStateCommand
 */
export interface UpdateStateCommand {
  /**
   *
   * @type {boolean}
   * @memberof UpdateStateCommand
   */
  isRunning: boolean
}
/**
 *
 * @export
 * @interface UpdateStateCommandDto
 */
export interface UpdateStateCommandDto {
  /**
   *
   * @type {boolean}
   * @memberof UpdateStateCommandDto
   */
  isRunning: boolean
  /**
   *
   * @type {boolean}
   * @memberof UpdateStateCommandDto
   */
  operationSucceeded: boolean
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSensorData(options: any = {}): FetchArgs {
      const localVarPath = `/SensorData`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSystemLog(options: any = {}): FetchArgs {
      const localVarPath = `/SystemLog`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'POST' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} startDate
     * @param {number} endDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSensorData(startDate: number, endDate: number, options: any = {}): FetchArgs {
      // verify required parameter 'startDate' is not null or undefined
      if (startDate === null || startDate === undefined) {
        throw new RequiredError(
          'startDate',
          'Required parameter startDate was null or undefined when calling readSensorData.'
        )
      }
      // verify required parameter 'endDate' is not null or undefined
      if (endDate === null || endDate === undefined) {
        throw new RequiredError(
          'endDate',
          'Required parameter endDate was null or undefined when calling readSensorData.'
        )
      }
      const localVarPath = `/SensorData`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (startDate !== undefined) {
        localVarQueryParameter['startDate'] = startDate
      }

      if (endDate !== undefined) {
        localVarQueryParameter['endDate'] = endDate
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {number} startDate
     * @param {number} endDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSystemLog(startDate: number, endDate: number, options: any = {}): FetchArgs {
      // verify required parameter 'startDate' is not null or undefined
      if (startDate === null || startDate === undefined) {
        throw new RequiredError(
          'startDate',
          'Required parameter startDate was null or undefined when calling readSystemLog.'
        )
      }
      // verify required parameter 'endDate' is not null or undefined
      if (endDate === null || endDate === undefined) {
        throw new RequiredError(
          'endDate',
          'Required parameter endDate was null or undefined when calling readSystemLog.'
        )
      }
      const localVarPath = `/SystemLog`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'GET' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (startDate !== undefined) {
        localVarQueryParameter['startDate'] = startDate
      }

      if (endDate !== undefined) {
        localVarQueryParameter['endDate'] = endDate
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @param {UpdateStateCommand} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateState(body: UpdateStateCommand, options: any = {}): FetchArgs {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateState.'
        )
      }
      const localVarPath = `/State`
      const localVarUrlObj = url.parse(localVarPath, true)
      const localVarRequestOptions = Object.assign({ method: 'PUT' }, options)
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      )
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers)
      const needsSerialization =
        <any>'UpdateStateCommand' !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.body = needsSerialization ? JSON.stringify(body || {}) : body || ''

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSensorData(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CreateSensorDataCommandDto> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).createSensorData(options)
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSystemLog(
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<CreateSystemLogCommandDto> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).createSystemLog(options)
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {number} startDate
     * @param {number} endDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSensorData(
      startDate: number,
      endDate: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetSensorDataQueryDto>> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).readSensorData(
        startDate,
        endDate,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {number} startDate
     * @param {number} endDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSystemLog(
      startDate: number,
      endDate: number,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Array<GetSystemLogQueryDto>> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).readSystemLog(
        startDate,
        endDate,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
    /**
     *
     * @param {UpdateStateCommand} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateState(
      body: UpdateStateCommand,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<UpdateStateCommandDto> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).updateState(
        body,
        options
      )
      return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
        return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then(
          (response) => {
            if (response.status >= 200 && response.status < 300) {
              return response.json()
            } else {
              throw response
            }
          }
        )
      }
    },
  }
}

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSensorData(options?: any) {
      return DefaultApiFp(configuration).createSensorData(options)(fetch, basePath)
    },
    /**
     *
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createSystemLog(options?: any) {
      return DefaultApiFp(configuration).createSystemLog(options)(fetch, basePath)
    },
    /**
     *
     * @param {number} startDate
     * @param {number} endDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSensorData(startDate: number, endDate: number, options?: any) {
      return DefaultApiFp(configuration).readSensorData(
        startDate,
        endDate,
        options
      )(fetch, basePath)
    },
    /**
     *
     * @param {number} startDate
     * @param {number} endDate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    readSystemLog(startDate: number, endDate: number, options?: any) {
      return DefaultApiFp(configuration).readSystemLog(startDate, endDate, options)(fetch, basePath)
    },
    /**
     *
     * @param {UpdateStateCommand} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateState(body: UpdateStateCommand, options?: any) {
      return DefaultApiFp(configuration).updateState(body, options)(fetch, basePath)
    },
  }
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createSensorData(options?: any) {
    return DefaultApiFp(this.configuration).createSensorData(options)(this.fetch, this.basePath)
  }

  /**
   *
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createSystemLog(options?: any) {
    return DefaultApiFp(this.configuration).createSystemLog(options)(this.fetch, this.basePath)
  }

  /**
   *
   * @param {number} startDate
   * @param {number} endDate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public readSensorData(startDate: number, endDate: number, options?: any) {
    return DefaultApiFp(this.configuration).readSensorData(
      startDate,
      endDate,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {number} startDate
   * @param {number} endDate
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public readSystemLog(startDate: number, endDate: number, options?: any) {
    return DefaultApiFp(this.configuration).readSystemLog(
      startDate,
      endDate,
      options
    )(this.fetch, this.basePath)
  }

  /**
   *
   * @param {UpdateStateCommand} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateState(body: UpdateStateCommand, options?: any) {
    return DefaultApiFp(this.configuration).updateState(body, options)(this.fetch, this.basePath)
  }
}
